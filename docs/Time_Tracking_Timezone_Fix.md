# תיקון אזור זמן (Timezone) במדידת זמן

## הבעיה

בגרסה שרצה בשרת (למשל Railway), **כל מדידה חדשה הופיעה מיד עם שעתיים** (02:00:00 ויותר) במקום 00:00:00. במחשב המקומי ההתנהגות הייתה תקינה.

## סיבת השורש

1. **בשרת** – `start_time` נשמר כ־`datetime.now().isoformat()` – כלומר **שעון מקומי של השרת**. בשרותי ענן (למשל UTC) מתקבל מחרוזת כמו `"2025-01-28T10:00:00"` **בלי** סימון timezone.

2. **בדפדפן** – ב־JavaScript,  
   `new Date("2025-01-28T10:00:00")`  
   (בלי `Z` או offset) מפורש כ־**שעה מקומית של המשתמש**.  
   אם המשתמש בישראל (UTC+2), זה 10:00 ישראל = 08:00 UTC.

3. **התוצאה** – השרת התכוון ל־10:00 UTC, אבל בדפדפן "ההתחלה" התפרשה כ־08:00 UTC, כלומר **שעתיים מוקדם יותר**. חישוב הזמן שעבר: `now - start` נתן בערך שעתיים גם כשהמדידה רק התחילה.

## הפתרון

- **שמירה ושליחה ב־UTC** עם סימון מפורש (סיומת `Z`).
- **אקאנד**:
  - בהתחלת מדידה:  
    `start_time = datetime.now(timezone.utc).isoformat().replace('+00:00', 'Z')`
  - בכל חישוב (עצירה, elapsed, ניקוי stale): פרסור `start_time` עם פונקציה שמזהה `Z` / `+00:00` ומחזירה `datetime` ב־UTC, והשוואה ל־`datetime.now(timezone.utc)`.
- **תאימות לאחור**: מחרוזות ישנות בלי `Z` מפורשות כ־naive (שעון מקומי של השרת) כמו קודם.

## שינויים בקוד

- **`app.py`**:
  - ייבוא: הוספת `timezone` מ־`datetime`.
  - `_parse_start_time(iso_str)` – מפרש מחרוזת ISO; אם יש `Z` או `+00:00` מחזיר datetime ב־UTC.
  - `_now_for_start(start_dt)` – מחזיר "עכשיו" ב־UTC אם `start_dt` עם timezone, אחרת `datetime.now()` (תאימות לאחור).
  - `api_time_tracking_start`: שמירת `start_time` ב־UTC עם `Z`.
  - `_drop_stale_active_sessions`, `_enrich_time_tracking_session`, `api_time_tracking_stop`: שימוש ב־`_parse_start_time` ו־`_now_for_start` לחישובי זמן.

## אימות

- אחרי העדכון, התחל מדידה חדשה בשרת – התצוגה צריכה להתחיל מ־00:00:00 ולעלות בהדרגה.
- מדידות ישנות (בלי `Z`) ממשיכות לעבוד בשרת בזכות הפרסור והשוואה ל־"עכשיו" בהתאם.
